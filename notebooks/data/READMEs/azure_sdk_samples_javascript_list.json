[{"README_text": "", "repo_name": "communication/communication-common/samples/.gitkeep", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/communication/communication-common/samples/.gitkeep", "language": ["JavaScript"]}, {"README_text": "", "repo_name": "core/core-auth/samples/.gitkeep", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-auth/samples/.gitkeep", "language": ["JavaScript"]}, {"README_text": "", "repo_name": "core/core-client/samples/.gitkeep", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-client/samples/.gitkeep", "language": ["JavaScript"]}, {"README_text": "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @summary This sample demonstrates how to implement a custom HttpClient.\n */\n\nimport { IncomingHttpHeaders } from \"http\";\nimport * as coreHttp from \"@azure/core-http\";\nimport got from \"got\";\n\n/**\n * Translates got incoming headers into core-http headers\n * @param headers\n * @returns\n */\nfunction toIncomingHeaders(headers: IncomingHttpHeaders): coreHttp.HttpHeadersLike {\n  const result = new coreHttp.HttpHeaders();\n  for (const [key, value] of Object.entries(headers)) {\n    if (Array.isArray(value) && value?.length) {\n      result.set(key, value![0]);\n    } else if (value) {\n      result.set(key, value as string);\n    }\n  }\n\n  return result;\n}\n\n/**\n * A custom HttpClient that uses `got` to send request.\n * NOTE: this is for demostrantion purpose only and is not a complete implementation.\n *       It only works for responses that are returned in text.\n */\nexport class GotHttpClient implements coreHttp.HttpClient {\n  async sendRequest(\n    httpRequest: coreHttp.WebResourceLike\n  ): Promise<coreHttp.HttpOperationResponse> {\n    console.log(`sending request using 'got' package...`);\n    const response = await got(httpRequest.url, {\n      method: httpRequest.method,\n      headers: httpRequest.headers.rawHeaders(),\n      searchParams: httpRequest.query,\n      retry: 0\n    });\n\n    return {\n      request: httpRequest,\n      status: response.statusCode,\n      headers: toIncomingHeaders(response.headers),\n      bodyAsText: response.body\n    };\n  }\n}\n\nconst clientOptions: coreHttp.ServiceClientOptions = {\n  httpClient: new GotHttpClient()\n};\n\nconst client = new coreHttp.ServiceClient(undefined, clientOptions);\nconst req: coreHttp.RequestPrepareOptions = {\n  url: `https://www.example.com`,\n  method: \"GET\"\n};\n\nclient.sendRequest(req).then(function(res: coreHttp.HttpOperationResponse) {\n  console.log(res.bodyAsText);\n});\n", "repo_name": "core/core-http/samples/gotHttpClient.ts", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-http/samples/gotHttpClient.ts", "language": ["JavaScript"]}, {"README_text": "# Azure Core LRO developer guide and samples\n\nHere we will expand on how to use `@azure/core-lro` by presenting a sample, and exploring on how to use the core concepts to build your own Long Running Operation methods returning pollers.\n\n## Sample\n\nIn this folder you will be able to see a simple sample file implementing a `Poller` and a `PollOperation` and then using them from a `main()` function.\n\nThe sample file:\n\n- [typescript/samplesClient.ts](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-lro/samples/typescript/samplesClient.ts)\n\n## Guide on implementing a LRO method\n\nThe following sections go through the core concepts explaining  how to build Long Running Operation methods returning pollers.\n\n### Implementing an operation\n\nTo work with a Long Running Operation, we need to define how to update, cancel and serialize the information related to the remote pending task.\n\nTo implement this class for your library or application, you'll need to import the definitions of a poll operation and its state.\n\n```typescript\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\n```\n\nA `PollOperation` is an interface that defines how to update the local reference of the state of the remote long running operation, just as well as how to request the cancellation of the same operation.\n\nBesides updating and cancelling, it also defines how to serialize its information, so that polling can be resumed at any time from a previously serialized operation (more at [Serializing an operation](#serializing-an-operation)).\n\n`PollOperationState` provides a basic state for the poll operation. It contains the minimal set of properties needed to keep track of a long running operation, and it's intended to be extended with any custom property that your program might need. The state can be updated any time, but it should be updated at least in three opportunities: when the operation starts, when it's finished, and when it's cancelled.\n\nTo be able to create your custom operations, you'll need to extend the `PollOperation` class with both your operation's state and the final result value. For this example, we'll think on the final result value to be `MyResult`, which can be any type.\n\n```typescript\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\n\nexport interface MyOperationState extends PollOperationState<MyResult> {\n  serviceClient: any; // You define all of these properties\n  myCustomString: string;\n  startedAt: Date;\n  finishedAt: Date;\n  // ... and so on\n}\n\nexport interface MyPollOperation extends PollOperation<MyOperationState, MyResult> {}\n```\n\nWe recommend making a utility function to create new instances of your operation. Just like the following:\n\n```typescript\nfunction makeOperation(\n  state: MyOperationState,\n): MyOperation {\n  return {\n    // We recommend creating copies of the given state,\n    // just to make sure that no references are left or manipulated by mistake.\n    state: {\n      ...state,\n    },\n    update,\n    cancel,\n    toString\n  };\n}\n```\n\nTo properly define an operation, you will need to have implemented these three functions: `update`, `cancel` and `toString`.\n\nA guide on how to write them follows.\n\n#### Your operation's update method\n\nThe `update` method defines how to request the remote service for updates on the status of the long running operation.\n\nIt optionally receives an object with an `abortSignal` property, from [@azure/abort-controller](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/abort-controller)'s `AbortSignalLike`.\n\nA more advanced use allows passing in a `fireProgress` function, which, if called, is responsible for triggering the\npoller's `onProgress` callbacks.\n\nHere is an example of how to write an update method for your operation:\n\n```typescript\nasync function update(\n  this: MyOperation,\n  options: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: MyOperationState) => void;\n  } = {}\n): Promise<MyOperation> {\n  let isDone: boolean = false;\n  let doFireProgress: boolean = false;\n\n  // Asynchronously call your service client...\n\n  // You might update the operation's state at any point\n  if (isDone) {\n    this.state.completed = true;\n    this.state.result = \"Done\";\n  }\n\n  // You can also arbitrarily report progress\n  if (doFireProgress) {\n    options.fireProgress(state);\n  }\n\n  return makeOperation(this.state);\n}\n```\n\n#### Your operation's cancel method\n\nThe operation's `cancel` method should attempt to cancel the pending operation, if it's allowed by the remote service. Otherwise, it should throw.\n\nIt only optionally receives an object with an `abortSignal` property, from [@azure/abort-controller](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/abort-controller)'s `AbortSignalLike`.\n\nIt returns a promise that should be resolved with an updated version of the poller's operation.\n\n```typescript\nasync function cancel(\n  this: MyOperation,\n  options: { abortSignal?: AbortSignalLike } = {}\n): Promise<MyOperation> {\n  // ... Reach out to your service to trigger the cancellation of the operation ...\n\n  return makeOperation(\n    {\n      ...this.state,\n      cancelled: true\n    }\n  );\n}\n```\n\n#### Serializing an operation\n\nThe operation's method `toString` returns a string with a serialized representation of the operation. It's useful when a poller wants to be resumed from a previously serialized state.\n\nThe deserialization of the operation has to be implemented within the constructor of a class that extends the Poller class. You can read more at [Resuming from a previous poller](#resuming-from-a-previous-poller).\n\n```typescript\nfunction toString(this: MyOperation): string {\n  return JSON.stringify({\n    state: {\n      ...this.state,\n      // Only the plain text properties, for example\n    }\n  });\n}\n```\n \n### Implementing a poller\n\n@azure/core-lro's `Poller` is a class that represents the definition of a program that polls through consecutive requests until it reaches a state of completion.\n\nA poller can be executed manually, by polling request by request by calling to the `poll()` method repeatedly, until its operation is completed. It also provides a way to wait until the operation finishes, by calling `pollUntilDone()`, which returns a promise. Pollers can also request the cancellation of the ongoing process (internally using `PollOperation`'s `cancel()` method).\n\nThe Poller needs two types to be defined, a type representing the state of the poller, which must include a basic set of properties from `PollOperationState<TResult>` (as mentioned in [Implementing an operation](#implementing-an-operation)), and a return type defined by `TResult`, which can be anything.\n\nTo implement a poller, you must pull in the definitions of your operation and extend @azure/core-lro's `Poller` class, as follows:\n\n```typescript\nimport { Poller } from \"@azure/core-lro\";\nimport { makeOperation, MyOperation, MyOperationState } from \"./myOperation\";\n\n// See that \"MyResult\" here is the type of the result\nexport class MyPoller extends Poller<MyOperationState, MyResult> {\n  constructor(\n    baseOperation?: MyOperation,\n    onProgress?: (state: MyOperationState) => void\n  ) {\n    let state: MyOperationState = {};\n\n    if (baseOperation) {\n      state = baseOperation.state;\n    }\n\n    const operation = makeOperation(state);\n\n    super(operation);\n\n    // Setting up the poller to call progress when the operation decides.\n    // This ties to the operation's update method, which receives a\n    // fireProgress method in the optional properties.\n    if (onProgress) {\n      this.onProgress(onProgress);\n    }\n  }\n\n  async delay(): Promise<void> {\n    // Your own implementation of a delay\n  }\n}\n```\n\nOnce defined, you'll be able to use your poller as shown below:\n\n```ts\nconst poller = new MyPoller();\n\n// Polling just once:\nawait poller.poll();\n\n// We can try to cancel the request here, by calling:\n//\n//     await poller.cancelOperation();\n//\n\n// Getting the final result:\nconst result = await poller.pollUntilDone();\n```\n\nThe Poller class implements the `PollerLike` interface, which allows poller implementations that avoid having to export the Poller's class directly, and instead only export the already instantiated poller with the `PollerLike` type.\n\nAn example of the definition of a client that returns an instantiated poller can be seen below:\n\n```ts\nclass Client {\n  public async makePoller: PollerLike<MyOperationState, MyResult> {\n    const poller = new MyPoller({});\n    // It might be preferred to return the poller after the first request is made,\n    // so that some information can be obtained right away.\n    await poller.poll();\n    return poller;\n  }\n}\n\n// No knowledge of the class MyPoller:\nconst poller: PollerLike<MyOperationState, MyResult> = myClient.makePoller();\n```\n\nA poller can be created through its constructor, then it can be polled until it's completed. At any point in time, the state of the poller can be obtained without delay through the getOperationState method. At any point in time, the intermediate forms of the result type can be requested without delay.\n\nOnce the underlying operation is marked as completed, the poller will stop and the final value will be returned.\n\nHere's an example usage of your client's poller:\n\n```ts\nconst poller = myClient.makePoller();\nconst state: MyOperationState = poller.getOperationState();\n\n// The intermediate result can be obtained at any time.\nconst result: MyResult | undefined = poller.getResult();\n\n// The final result can only be obtained after the poller finishes.\nconst result: MyResult = await poller.pollUntilDone();\n```\n\n#### Resuming from a previous poller\n\nPollers by default have a method called `toString` that invokes the operation's `toString` method. It can be used to store the state of a poller indefinitely, to then resume by creating another poller at any time in the future.\n\nIf an operation's `toString` method is defined as follows:\n\n```ts\nfunction toString(this: TestOperation): string {\n  return JSON.stringify({\n    state: this.state\n  });\n}\n```\n\nA custom implementation of a poller can deserialize it by receiving this string and converting it back to JSON, like in the following example:\n\n```ts\nexport class MyPoller extends Poller<MyOperationState, string> {\n  constructor(\n    baseOperation: string | undefined\n  ) {\n    let state: MyOperationState = {};\n    if (baseOperation) {\n      state = {\n        ...JSON.parse(baseOperation).state,\n        ...state\n      };\n    }\n    const operation = {\n      state,\n      // ...\n    }\n    super(operation);\n  }\n}\n```\n", "repo_name": "core/core-lro/samples", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-lro/samples", "language": ["JavaScript"]}, {"README_text": "", "repo_name": "core/core-util/samples/.gitkeep", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-util/samples/.gitkeep", "language": ["JavaScript"]}, {"README_text": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"outDir\": \"typescript/dist\",\n    \"lib\": [\n      \"ES6\"\n    ]\n  },\n  \"include\": [\n    \"typescript/src/**.ts\"\n  ],\n  \"exclude\": [\n    \"typescript/*.json\",\n    \"**/node_modules/\",\n    \"../node_modules\",\n    \"../typings\"\n  ]\n}\n", "repo_name": "eventhub/mock-hub/samples/tsconfig.json", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/eventhub/mock-hub/samples/tsconfig.json", "language": ["JavaScript"]}, {"README_text": "# Table of contents\n\n- [Introduction](#introduction)\n- [Authenticating client-side browser applications](#authenticating-client-side-browser-applications)\n- [Authenticating server-side applications](#authenticating-server-side-applications)\n  - [Authenticating User Accounts](#authenticating-user-accounts)\n  - [Authenticating User Accounts with developer tools](#authenticating-user-accounts-with-developer-tools)\n  - [Authenticating Service Principals](#authenticating-service-principals)\n  - [Authenticating Azure Hosted Applications](#authenticating-azure-hosted-applications)\n- [Chaining credentials](#chaining-credentials)\n- [Authenticating With Azure Stack using Azure Identity](#authenticating-with-azure-stack-using-azure-identity)\n- [Advanced Examples](#advanced-examples)\n  - [Custom Credentials](#custom-credentials)\n  - [Implementing the TokenCredential Interface](#implementing-the-tokencredential-interface).\n  - [Authenticating with a pre-fetched access token](#authenticating-with-a-pre-fetched-access-token).\n  - [Authenticating with MSAL directly](#authenticating-with-msal-directly).\n    - [Authenticating with the @azure/msal-node Confidential Client](#authenticating-with-the-azuremsal-node-confidential-client).\n    - [Authenticating with the @azure/msal-browser Public Client](#authenticating-with-the-azuremsal-browser-public-client).\n  - [Authenticating with Key Vault Certificates](#authenticating-with-key-vault-certificates)\n  - [Rolling Certificates](#rolling-certificates)\n  - [Authenticate on behalf of](#authenticate-on-behalf-of)\n  - [Control user interaction](#control-user-interaction)\n  - [Persist user authentication data](#persist-user-authentication-data)\n    - [Persist the token cache](#persist-the-token-cache)\n    - [Use a named token cache](#use-a-named-token-cache)\n    - [Persist the authentication record](#persist-the-authentication-record)\n    - [Silent authentication with authentication record and token cache persistence options](#silent-authentication-with-authentication-record-and-token-cache-persistence-options)\n    - [Allow unencrypted storage](#allow-unencrypted-storage)\n  - [Authenticate national clouds](#authenticate-national-clouds)\n\n## Introduction\n\nAuthenticating your application, users, and principals is an integral part of working with the Azure client libraries. The Azure Identity library provides multiple ways to gain access to the Azure services, each with a flexible configuration that covers most scenarios. There is sample code in [JavaScript](https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/identity/identity/samples/v2/javascript) and [TypeScript](https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/identity/identity/samples/v2/typescript) to cover the basic authentication scenarios. This document covers several use cases of Identity with greater context and links to the underlying authentication flows and other available documentation.\n\n## Authenticating client-side browser applications\n\nFor client-side applications running in the browser, the `InteractiveBrowserCredential` provides the most direct user authentication experience. It's the only credential type that we support in the browser. To get started, register your application in the Microsoft Identity platform and set the proper permissions.\n\n- [Register a single page application](https://docs.microsoft.com/azure/active-directory/develop/scenario-spa-app-registration) in the Microsoft identity platform\n- Configure the app registration with a redirect URI to specify where the Microsoft identity platform should redirect the client along with any security tokens.\n  - If using v1 of `@azure/identity` package, follow the instructions at [Redirect URI: MSAL.js 1.0 with implicit flow](https://docs.microsoft.com/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-10-with-implicit-flow) to set the redirect URI.\n  - If using v2 of `@azure/identity` package, follow the instructions at [Redirect URI: MSAL.js 2.0 with auth code flow](https://docs.microsoft.com/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow)\n- Ensure that your application has the correct permission for the APIs it intends to use.\n  - In your app registration in the Azure portal, go to `API Permissions`\n  - Click on `Add a permission`\n  - Select the API you want to use. For example, if you're using any of our management/control plane packages (the ones whose name starts with `@azure/arm-`), you should select **Azure Service Management**.\n- Ensure that your AAD Application has enabled public authentication flows:\n  - Go to Azure Active Directory in the Azure portal and find your app registration.\n  - Navigate to the **Authentication** section.\n  - Under **Advanced settings**, select **yes** on the option **Allow public client flows**.\n\nCopy the client ID and tenant ID from the **Overview** section of your app registration in the Azure portal and use it in the below code snippet where we authenticate a `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] using the `InteractiveBrowserCredential`.\n\n```ts\nfunction withInteractiveBrowserCredential() {\n  const credential = new InteractiveBrowserCredential({\n    tenantId: \"<YOUR_TENANT_ID>\",\n    clientId: \"<YOUR_CLIENT_ID>\"\n  });\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\nIf your project is already using MSAL to authenticate on the browser, or if you're looking for more advanced authentication scenarios in the browser, the Azure SDK makes it easy to use MSAL directly to authenticate our clients: [Authenticating with the @azure/msal-browser Public Client](#authenticating-with-the-azuremsal-browser-public-client).\n\n## Authenticating server-side applications\n\nFor server-side applications, we provide options that vary from a minimal configuration with sensible defaults using the `DefaultAzureCredential` to more specialized credentials.\n\n- To get started, you can always rely on interactive authentication of your user account, which requires minimal setup.\n- As you develop your application, you may want to sign in using the developer tools like Azure CLI or Azure PowerShell, to avoid signing in interactively every time you run your application.\n- As you deploy your application to Azure App Service or run it in a virtual machine, you may want to use [Managed Identity](https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview).\n\nWe also provide a way to chain multiple credentials so that they try to authenticate sequentially until one of them succeeds. Chaining credentials will allow your code to work in multiple environments, including your local development tools. For more information, go to the section: [Chaining credentials](#chaining-credentials).\n\nOne such chained credential that we provide out of the box is `DefaultAzureCredential`.\n\n### Authenticating User Accounts\n\nAuthenticating user accounts is the easiest way to get started with minimal set up. For production scenarios, we recommend authenticating using service principals or managed identities, which are listed in the later sections.\n\n| Credential with example                                                                     | Usage                                                                                                                   | Setup required                                                   |\n| ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |\n| [InteractiveBrowserCredential](#authenticating-a-user-account-interactively-in-the-browser) | Interactively authenticates a user with the default system browser.                                                     | None                                                             |\n| [DeviceCodeCredential](#authenticating-a-user-account-with-device-code-flow)                | Interactively authenticates a user by having user post the provided code in the given url on same or different machine. | None                                                             |\n| [AuthorizationCodeCredential](#authenticating-a-user-account-with-auth-code-flow)           | Authenticate a user with a previously obtained authorization.                                                           | Yes, please see the linked example.                              |\n| [UsernamePasswordCredential](#authenticating-a-user-account-with-username-and-password)     | Authenticates a user with a username and password.                                                                      | [Application Registration][quickstart-register-app] is required. |\n\n### Authenticating User Accounts with developer tools\n\n| Credential with example                                                           | Usage                                                                                                                                                                                                                                                                                                                  | Setup                                                                                                                                                                                                    |\n| --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|[AzureDeveloperCliCredential](#authenticatin-a-user-account-with-azure-developer-cli) | Authenticate in a development environment with Azure Developer CLI. | [Install the Azure Developer CLI](https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd) and login using the [`azd auth login` command](https://learn.microsoft.com/azure/developer/azure-developer-cli/reference?source=recommendations#azd-auth-login).\n| [AzureCliCredential](#authenticating-a-user-account-with-azure-cli)               | Authenticate in a development environment with the Azure CLI.                                                                                                                                                                                                                                                          | [Install Azure CLI](https://docs.microsoft.com/cli/azure/install-azure-cli) and [login using az cli command](https://docs.microsoft.com/cli/azure/authenticate-azure-cli)                                |\n| [AzurePowerShellCredential](#authenticating-a-user-account-with-azure-powershell) | Authenticate in a development environment with Azure PowerShell.                                                                                                                                                                                                                                                       | [Install Azure PowerShell](https://docs.microsoft.com/powershell/azure/install-az-ps) and [login using the `Connect-AzAccount` cmdlet](https://docs.microsoft.com/powershell/azure/authenticate-azureps) |\n| [DefaultAzureCredential](#authenticating-with-defaultazurecredential)             | Tries `AzureDeveloperCliCredential`, `AzureCliCredential`, `AzurePowerShellCredential`, and other credentials sequentially until one of them succeeds. Use this to have your application authenticate using developer tools, service principals, or managed identity based on what's available in the current environment without changing your code. |\n\n### Authenticating Service Principals\n\nAn Azure service principal is an identity created for use with applications, hosted services, and automated tools to access Azure resources. The roles assigned by the service principal will determine what resources are accessible. For security reasons, use service principals through automation rather than allowing them to log in with a user identity.\n\nTo learn more, read [Application and service principal objects in Azure Active Directory][app-register-service-principal]\n\n**Setup**:\n\n- [Application registration][quickstart-register-app]\n- [Create a Service Principal with the Azure CLI][service_principal_azure_cli] or [Create an Azure service principal with Azure PowerShell][service_principal_azure_powershell]\n\n| Credential with example                                                                      | Usage                                                                                                                                                                                                                                                                                                                                           |\n| -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ClientSecretCredential](#authenticating-a-service-principal-with-a-client-secret)           | Authenticates a service principal using a secret.                                                                                                                                                                                                                                                                                               |\n| [ClientCertificateCredential](#authenticating-a-service-principal-with-a-client-certificate) | Authenticates a service principal using a certificate.                                                                                                                                                                                                                                                                                          |\n| [ClientAssertionCredential](#authenticating-a-service-principal-with-a-client-assertion) | Authenticating a service principal with a client assertion. |\n| [EnvironmentCredential](#authenticating-a-service-principal-with-environment-credentials)    | Authenticates a service principal or user via credential information specified in environment variables.                                                                                                                                                                                                                                        |\n| [DefaultAzureCredential](#authenticating-with-defaultazurecredential)                        | Tries `EnvironmentCredential`, `AzureCliCredential`, `AzurePowerShellCredential`, and other credentials sequentially until one of them succeeds. Use this to have your application authenticate using developer tools, service principals, or managed identity based on what's available in the current environment without changing your code. |\n\n### Authenticating Azure Hosted Applications\n\nIf your application is hosted in Azure, you can make use of [Managed Identity](https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview) for hassle free authentication in your production environments.\n\n| Credential with example                                                     | Usage                                                                                                                                                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|[WorkloadIdentityCredential](#authenticating-in-azure-with-workload-identity) | Authenticate in Azure Kubernetes environment with [Azure Active Directory (Azure AD) workload identities (preview)](https://learn.microsoft.com/azure/active-directory/workload-identities/workload-identities-overview), which [integrates with the Kubernetes native capabilities](https://learn.microsoft.com/azure/aks/workload-identity-overview) to federate with any external identity providers. |\n| [ManagedIdentityCredential](#authenticating-in-azure-with-managed-identity) | Authenticate in a virtual machine, App Service, Functions app, Cloud Shell, or AKS environment on Azure, with system-assigned managed identity, user-assigned managed identity, or app registration (when working with AKS pod identity).    |\n| [DefaultAzureCredential](#authenticating-with-defaultazurecredential)       | Tries `EnvironmentCredential`, `ManagedIdentityCredential`, `AzureCliCredential`, `AzurePowerShellCredential`, and other credentials sequentially until one of them succeeds. Use this to have your application authenticate using developer tools, service principals or managed identity based on what is available in the current environment without changing your code. |\n\n### Examples\n\n#### Authenticating with `DefaultAzureCredential`\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `DefaultAzureCredential`. There's also [a runnable sample](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/identity/identity/samples/v2/typescript/src/defaultAzureCredential.ts) to create a Key Vault key client you can copy-paste. The `DefaultAzureCredential` makes for a terrific starting point as it provides sane defaults with minimal configuration and chains multiple credentials together. While you may outgrow it eventually, it is a sensible first choice for most scenarios where the application is intended to ultimately be run in the Azure Cloud.\n\n```ts\n/**\n * The default credential first checks environment variables for configuration.\n * If the environment configuration is incomplete, it will try managed identity.\n */\nfunction withDefaultAzureCredential() {\n  const credential = new DefaultAzureCredential();\n  const client = new SecretClient(`https://key-vault-name.vault.azure.net`, credential);\n}\n```\n\n#### Authenticating a user-assigned managed identity with `DefaultAzureCredential`\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `DefaultAzureCredential`, deployed to an Azure resource with a user-assigned managed identity configured.\n\nFor more information about configuring a user-assigned managed identity for an Azure resource, refer to [What are managed identities for Azure resources][azure_managed_identities].\n\n```ts\n/**\n * The default credential will use the user-assigned managed identity with the specified client ID.\n */\nfunction withDefaultAzureCredential() {\n  // Alternatively, you may set the environment variable AZURE_CLIENT_ID=\"<MANAGED_IDENTITY_CLIENT_ID>\" and omit the `managedIdentityClientId`\n  // option when using `DefaultAzureCredential` - the two approaches are equivalent.\n  const credential = new DefaultAzureCredential({\n    managedIdentityClientId: \"<MANAGED_IDENTITY_CLIENT_ID>\"\n  });\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a user account interactively in the browser\n\nFor clients with a default browser available and client-side applications running in the browser, the `InteractiveBrowserCredential` provides the most direct user authentication experience. In the sample below, an application authenticates a `SecretClient` from the [@azure/service-bus][service_bus_client_library] using the `InteractiveBrowserCredential`.\n\nFor Node.js, if a `clientId` is provided, the Azure Active Directory application will need to be configured to have a \"Mobile and desktop applications\" redirect endpoint. Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://docs.microsoft.com/azure/active-directory/develop/scenario-desktop-app-registration#redirect-uris).\n\nFor client-side applications running in the browser, the `InteractiveBrowserCredential` is the only credential type that is supported. For more information, see [Authenticating client-side browser applications](#authenticating-client-side-browser-applications).\n\n```ts\nfunction withInteractiveBrowserCredential() {\n  const credential = new InteractiveBrowserCredential({\n    tenantId: \"<YOUR_TENANT_ID>\",\n    clientId: \"<YOUR_CLIENT_ID>\"\n  });\n  const client = new ServiceBusClient(\"<your-service-bus-endpoint>\", credential);\n}\n```\n\n#### Authenticating a service principal with a client secret\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `ClientSecretCredential`. There's also [a runnable sample](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/identity/identity/samples/v2/typescript/src/clientSecretCredential.ts) to create a Key Vault key client you can copy-paste.\n\nYou'll need to:\n\n- [Create an application registration][quickstart-register-app]\n- [Create a Service Principal with the Azure CLI][service_principal_azure_cli] or [Create an Azure service principal with Azure PowerShell][service_principal_azure_powershell]\n\nTo learn more about service principals, see [Application and service principal objects in Azure Active Directory][app-register-service-principal].\n\nIn the following sample, an application authenticates a `SecretClient` from the [@azure/service-bus][service_bus_client_library] using the `ClientSecretCredential`:\n\n```ts\n/**\n *  Authenticate with client secret.\n */\nfunction withClientSecretCredential() {\n  const credential = new ClientSecretCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    \"<YOUR_CLIENT_SECRET>\"\n  );\n  const client = new ServiceBusClient(\"<your-service-bus-endpoint>\", credential);\n}\n```\n\n#### Authenticating a service principal with environment credentials\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `EnvironmentCredential`. The `EnvironmentCredential`:\n\n- Looks for well-known environment variable names to determine how it should authenticate.\n- Acts as a wrapper for the `ClientSecretCredential`, `ClientCertificateCredential`, or `UsernamePasswordCredential`, depending on which environment variables are present.\n\nYou'll need to:\n\n- [Create an application registration][quickstart-register-app]\n- [Create a Service Principal with the Azure CLI][service_principal_azure_cli] or [Create an Azure service principal with Azure PowerShell][service_principal_azure_powershell]\n- Provide the environment variables:\n  - `AZURE_TENANT_ID`, containing the AD tenant ID or name.\n  - `AZURE_CLIENT_ID`, containing the ID of the user/service principal to authenticate as.\n  - `AZURE_CLIENT_SECRET`, containing a client secret created belonging to the same user/service principal.\n\nTo learn more about service principals, see [Application and service principal objects in Azure Active Directory][app-register-service-principal].\n\n```ts\n/**\n *  Authenticate using the AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_CLIENT_SECRET environment variables.\n */\nfunction withEnvironmentCredential() {\n  let credential = new EnvironmentCredential();\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a service principal with a client certificate\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `ClientCertificateCredential`.\n\nYou'll need to:\n\n- [Create an application registration][quickstart-register-app]\n- [Create a Service Principal with the Azure CLI][service_principal_azure_cli] or [Create an Azure service principal with Azure PowerShell][service_principal_azure_powershell]\n\nTo learn more about service principals, see [Application and service principal objects in Azure Active Directory][app-register-service-principal].\n\n```ts\n/**\n *  Authenticate with a client certificate.\n */\nfunction withClientCertificateCredential() {\n  let credential = new ClientCertificateCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    \"<PATH_TO_CERTIFICATE>\"\n  );\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a service principal with a client assertion\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `ClientAssertionCredential`.\n\nYou'll need to:\n\n- [Create an application registration][quickstart-register-app]\n- [Create a Service Principal with the Azure CLI][service_principal_azure_cli] or [Create an Azure service principal with Azure PowerShell][service_principal_azure_powershell]\n- [Register the certificate with the Microsoft Identity platform][register_certificate_app_registration]\n\nTo learn more about service principals, see [Application and service principal objects in Azure Active Directory][app-register-service-principal].\n\n```ts\n/**\n *  Authenticate with a client assertion.\n */\nfunction withClientAssertionCredential() {\n  let credential = new ClientAssertionCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    <yourGetAssertionCallbackFunction()>\n  );\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\nYou'll need to implement your own `getAssertion()` callback function that will return an [assertion in an encoded JWT format][client_assertion_jwt].\n\n##### Creating a callback function to return assertion\n\nThis example demonstrates a callback function for creating an assertion from a client certificate. The default value of authority host should be `https://login.microsoftonline.com/${tenantId}`.\n\n```ts\n async function getAssertion(): Promise<string> {\n      const jwtoken = await createJWTTokenFromCertificate(\"<AUTHORITY_HOST>\", \"<YOUR_CLIENT_ID>\", \"<YOUR_CERTIFICATE_PATH>\");\n      return jwtoken;\n}\n```\n\nFor example, the following function creates an encoded and signed JWT assertion token from the client certificate:\n\n```ts\nimport * as tls from \"tls\";\nimport * as net from \"net\";\nimport * as fs from \"fs\";\nimport * as uuid from \"uuid\";\nimport * as jwt from \"jsonwebtoken\";\nimport ms from 'ms';\n\nasync function createJWTTokenFromCertificate(authorityHost: string,\n  clientId: string,\n  certificatePath: string) {\n\n  const privateKeyPemCert = fs.readFileSync(certificatePath);\n  const audience = `${authorityHost}/v2.0`;\n  const secureContext = tls.createSecureContext({\n    cert: privateKeyPemCert,\n  });\n  const secureSocket = new tls.TLSSocket(new net.Socket(), { secureContext });\n  secureSocket.destroy();\n  const cert = secureSocket.getCertificate() as tls.PeerCertificate;\n  const signedCert = jwt.sign({}, privateKeyPemCert, {\n    header: {\n      alg:\"RS256\",\n      typ: \"JWT\",\n      x5t: Buffer.from(cert.fingerprint256, \"hex\").toString(\"base64\")\n    },\n    algorithm: \"RS256\",\n    audience: audience,\n    jwtid: uuid.v4(),\n    expiresIn: ms('1 h'),\n    subject: clientId,\n    issuer: clientId\n  })  \n  return signedCert;  \n}\n```\n#### Authenticating a user account with device code flow\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `DeviceCodeCredential`. The `DeviceCodeCredential` offers a credential that can be used with little to no setup. The user can use the browser of their choice to complete the authentication process.\n\nTo authenticate a user through device code flow, complete the following steps:\n\n1. Go to Azure Active Directory in Azure portal and find your app registration.\n2. Navigate to the **Authentication** section.\n3. Under **Advanced settings**, select `yes` on the option `Allow public client flows`.\n\nYou also need to be the administrator of your tenant to grant consent to your application when you log in for the first time.\n\nIf you can't configure the device code flow option on your Active Directory, it may require your app to be multi-tenant. To make your app multi-tenant:\n\n1. Navigate to the **Authentication** panel.\n2. Select **Accounts in any organizational directory**.\n3. Select **yes** for **Treat application as Public Client**.\n\n```ts\n/**\n *  Authenticate with a device code.\n */\nfunction withDeviceCodeCredential() {\n  let credential = new DeviceCodeCredential(\n    process.env.AZURE_TENANT_ID,\n    process.env.AZURE_CLIENT_ID,\n    // In this scenario you may also omit this parameter since the default behavior is to log the message to the console\n    (deviceCodeInfo) => {\n      console.log(deviceCodeInfo.message);\n    }\n  );\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a user account with username and password\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `UsernamePasswordCredential`. The user must **not** have Multi-factor auth turned on.\n\nApart from user name and password, this credential requires you to know the tenant ID and client ID. To get the client ID, first [register your application][quickstart-register-app].\n\n```ts\n/**\n *  Authenticate with a username and password.\n */\nfunction withUsernamePasswordCredential() {\n  let credential = new UsernamePasswordCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    \"<USERNAME>\",\n    \"<PASSWORD>\"\n  );\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a user account with auth code flow\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `AuthorizationCodeCredential` on a Node.js service intended as the back-end for a web application. This can be useful when you want complete control over the authentication flow or when the `InteractiveBrowserCredential` doesn't fit your use case.\n\nFirst, [register your application][quickstart-register-app] and get your client ID, tenant ID and redirect URL.\n\nNext, prompt the user to login at the URL documented at [Microsoft identity platform and OAuth 2.0 authorization code flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-authorization-code). You'll need the client ID, tenant ID, redirect URL, and the scopes your application plans to access.\n\nThen create an API at the redirect URL with the following code to access the Key Vault service.\n\nTo learn more about scopes and permissions, see [Scopes and permissions](https://docs.microsoft.com/azure/active-directory/develop/v2-permissions-and-consent#scopes-and-permissions).\n\nFor a complete example using the authorization code flow in Electron, please refer to [our electron sample](https://github.com/Azure/azure-sdk-for-js/blob/main/samples/frameworks/electron/ts/src/authProvider.ts)\n\n```ts\n/**\n * Authenticate with authorization code.\n */\nfunction withAuthCodeCredential() {\n  const credential = new AuthorizationCodeCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    \"<AUTH_CODE_FROM_QUERY_PARAMETERS>\",\n    \"<REDIRECT_URL>\"\n  );\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a user account with Azure CLI\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `AzureCliCredential` on a workstation with Azure CLI installed and signed in.\n\n##### Configure the Azure CLI\n\nSign in using the [Azure CLI][azure_cli]\n\n```bash\n# As a user:\naz login\n\n# As a service principal:\naz login --service-principal --username <client-id> --password <client-secret> --tenant <tenant-id>\n```\n\nIf the account / service principal has access to multiple tenants, make sure the desired tenant or subscription is in the state \"Enabled\" in the output from command:\n\n```bash\naz account list\n```\n\nBefore you use AzureCliCredential in the code, run:\n\n```bash\naz account get-access-token\n```\n\nto verify the account has been successfully configured.\n\n##### Use the Azure CLI Credential\n\n```ts\n/**\n * Authenticate with Azure CLI.\n */\nfunction withAzureCliCredential() {\n  // As you can see in this example, the AzureCliCredential does not take any parameters,\n  // instead relying on the Azure CLI authenticated user to authenticate.\n  const credential = new AzureCliCredential();\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a User Account with Azure PowerShell\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `AzurePowerShellCredential` on a workstation with Azure PowerShell installed and authenticated.\n\n##### Configure Azure PowerShell\n\nSign in using [Azure PowerShell][azure_powershell]:\n\n```powershell\nPS> Connect-AzAccount\n```\n\nIf the account/service principal has access to multiple tenants (subscriptions), ensure that the `Get-AzContext` cmdlet returns the correct subscription:\n\n```powershell\nPS> Get-AzContext\n\n... <subscription information here> ...\n\n```\n\nIf the wrong subscription ID is shown, use the `Set-AzContext` cmdlet to change the active Azure context:\n\n```powershell\nPS> Set-AzContext -Subscription \"<subscription id>\"\n```\n\nTo verify that the account has been successfully configured, try running the `Get-AzAccessToken` cmdlet:\n\n```powershell\nPS> Get-AzAccessToken\n\nToken     : eyJ... <full access token will be shown in terminal> ...\nExpiresOn : 11/12/2013 5:43:21 AM +00:00\nType      : Bearer\nTenantId  : <tenant id>\nUserId    : <user id>\n\n```\n\n##### Use the Azure PowerShell Credential\n\n```ts\n/**\n * Authenticate with Azure PowerShell\n */\nfunction withAzurePowerShellCredential() {\n  // Like the Azure CLI Credential, the Azure PowerShell Credential does not accept any\n  // options or parameters, and uses the current user session within the Az.Account PowerShell\n  // module.\n  const credential = new AzurePowerShellCredential();\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating a User Account with Azure Developer CLI\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] client library using the `AzureDeveloperCliCredential` on a workstation with the Azure Developer CLI installed and signed in.\n\n##### Configure Azure Developer CLI\n\nSign in using the [Azure Developer CLI](https://learn.microsoft.com/azure/developer/azure-developer-cli/reference?source=recommendations#azd-auth-login):\n\n```bash\n# As a user:\nazd auth login\n\n# As a service principal:\nazd auth login --client-id <client-id> --client-secret <client-secret> --tenant-id <tenant-id>\n```\n\n##### Use Azure Developer CLI Credential\n\n```ts\n/**\n * Authenticate with Azure Developer CLI.\n */\nfunction withAzureDeveloperCliCredential() {\n  // As you can see in this example, the AzureDeveloperCliCredential does not take any parameters,\n  // instead relying on the Azure Developer CLI authenticated user to authenticate.\n  const credential = new AzureDeveloperCliCredential();\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating in Azure with Workload Identity\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] using the `WorkloadIdentityCredential` in an AKS environment.\n\n```ts\n/**\n * Authenticate with workload identity.\n */\nfunction withWorkloadIdentityCredential() {\n  const credential = new WorkloadIdentityCredential()\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n\n/**\n * Authenticate with default Azure identity.\n */ \nfunction withDefaultAzureCredential() {\n  const credential = new DefaultAzureCredential({workloadIdentityClientId: \"<WORKLOAD_IDENTITY_CLIENT_ID>\"})\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n#### Authenticating in Azure with managed identity\n\nThis example demonstrates authenticating the `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] using the `ManagedIdentityCredential` in a virtual machine, App Service, Functions app, Cloud Shell, or AKS environment on Azure, with system-assigned or user-assigned managed identity enabled.\n\nFor more information about configuring your Azure resource for managed identity, see [Configure managed identities for Azure resources](https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/qs-configure-cli-windows-vm).\n\n```ts\n/**\n * Authenticate with a system-assigned managed identity.\n */\nfunction withSystemAssignedManagedIdentityCredential() {\n  const credential = new ManagedIdentityCredential();\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n\n/**\n * Authenticate with a user-assigned managed identity.\n */\nfunction withUserManagedIdentityCredential() {\n  const credential = new ManagedIdentityCredential(\"<USER_ASSIGNED_MANAGED_IDENTITY_CLIENT_ID>\");\n\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n## Chaining credentials\n\nThe `ChainedTokenCredential` class provides the ability to link together multiple credential instances to be tried sequentially when authenticating. The following example demonstrates creating a credential that will attempt to authenticate a `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] using managed identity and fall back to certificate authentication if a managed identity is unavailable in the current environment.\n\n```ts\nfunction withChainedTokenCredential() {\n  const credential = new ChainedTokenCredential(\n    new ManagedIdentityCredential(\"<YOUR_CLIENT_ID>\"),\n    new ClientSecretCredential(\"<YOUR_TENANT_ID>\", \"<YOUR_CLIENT_ID>\", \"<YOUR_CLIENT_SECRET>\")\n  );\n  const client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n}\n```\n\n## Authenticating With Azure Stack using Azure Identity\n\n### Determine the Azure Authority Host for Azure Stack\n\nIn PowerShell, run this command or have your Azure Stack administrator run this command:\n\n```powershell\nGet-AzEnvironment -Name <Name-of-Azure-Stack-Instance>\n```\n\nThe output will be in the following format:\n\n```\nName Resource-Manager-Url ActiveDirectory-Authority\n---- -------------------- -------------------------\n<Name> <Resource-Manager-Url> <ActiveDirectory-Authority>\n```\n\nThe ActiveDirectory Authority in the output will be your Azure Authority Host\n\n### Determine the Tenant ID for Azure Stack\n\nIf the Identity provider of your Azure Stack is Azure Active Directory (Azure AD), contact your Azure Stack administrator to find your tenant ID. Otherwise, if the Identity provider of your Azure Stack is Active Directory Federation Services (ADFS), your tenant ID is `adfs`.\n\n### Authentication example\n\n**Code Setup**\n\nThe following example demonstrates authenticating a `SecretClient` from the [@azure/keyvault-secrets][secrets_client_library] against an Azure Key Vault hosted in Azure Stack.\n\n```ts\nfunction main() {\n  const credential = new ClientSecretCredential(\n    \"<YOUR_TENANT_ID>\",\n    \"<YOUR_CLIENT_ID>\",\n    \"<YOUR_CLIENT_SECRET>\",\n    {\n      authorityHost: \"Azure Stack Authority Host From Previous Step\"\n    }\n  );\n\n  const client = new SecretClient(\"<KEYVAULT_URL_IN_AZURE_STACK>\", credential);\n}\n```\n\n## Advanced Examples\n\n### Custom Credentials\n\nThe `@azure/identity` library covers a broad range of Azure Active Directory authentication scenarios. However, we understand there are cases in which the credentials provided might not meet the specific needs of your application. Some applications might avoid taking a dependency on the `@azure/identity` package. In such cases, you may want to write your custom credential.\n\nIn this section, we'll examine some such scenarios.\n\n### Implementing the TokenCredential Interface\n\nThe [@azure/core-auth][core_auth] package exports a `TokenCredential` interface. The interface is used by the `@azure/identity` package to define a standard public API for all of the Identity credentials we offer. Here's how this type looks in `@azure/core-auth`:\n\n```ts\nexport interface TokenCredential {\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;\n}\n```\n\nTo satisfy this interface, one has to provide an object with a `getToken` function. This function will always receive a `scope` parameter, and should generally receive a second parameter, an options object. This `getToken` function is expected to return an object compatible with `@azure/core-auth`'s `AccessToken` interface, which is defined as follows:\n\n```ts\nexport interface AccessToken {\n  expiresOnTimestamp: number;\n  token: string;\n}\n```\n\nAs long as a valid `AccessToken` is returned, the parameters are not required to be used by a method implementing the `TokenCredential` interface. So, the simplest possible object compatible with the `TokenCredential` interface is one that has a `getToken` method that may return either null, or an object with two properties, a numeric property called `expiresOnTimestamp`, and a string property called `token`. Example:\n\n```ts\nconst mySimpleCredential = {\n  getToken() {\n    return {\n      expiresOnTimestamp: Date.now() + 1000, // Expires in a second\n      token: \"my access token\"\n    };\n  }\n};\n```\n\n### Authenticating with a pre-fetched access token\n\nThere are cases in which it's convenient to create custom credentials. For example, when a token is pre-fetched, a custom `TokenCredential` can return that token as an `AccessToken` to the Azure SDK clients.\n\nIn this example, `StaticTokenCredential` implements the `TokenCredential` abstraction. It takes a pre-fetched access token in its constructor as an [AccessToken](https://docs.microsoft.com/javascript/api/@azure/core-auth/accesstoken) and returns that from its implementation of `getToken()`.\n\n**Prerequisites**\n\nInstall the [@azure/core-auth][core_auth] package.\n\n```ts\nimport { TokenCredential, AccessToken } from \"@azure/core-auth\";\n\nclass StaticTokenCredential implements TokenCredential {\n  // AccessToken is an object with two properties:\n  // - A \"token\" property with a string value.\n  // - And an \"expiresOnTimestamp\" property with a numeric unix timestamp as its value.\n  constructor(private accessToken: AccessToken) {}\n  async getToken(): Promise<AccessToken> {\n    return this.accessToken;\n  }\n}\n```\n\nOnce the application has defined this credential, it can authenticate Azure SDK clients with a pre-fetched `AccessToken`. The following example shows how an application already using some other mechanism for acquiring tokens (the hypothetical method `getTokenForScope()`) could use the `StaticTokenCredential` to authenticate a `SecretClient` from `@azure/keyvault-secrets`.\n\n```ts\nimport { SecretClient } from \"@azure/keyvault-secrets\";\n\n// StaticTokenCredential would be defined before the main() function...\n\nasync function main() {\n  const accessToken = getTokenForScope(\"https://vault.azure.net/.default\");\n\n  // In this case, `accessToken` has to contain two properties:\n  // - A \"token\" property with a string value.\n  // - And an \"expiresOnTimestamp\" property with a numeric unix timestamp as its value.\n\n  const credential = new StaticTokenCredential(accessToken);\n\n  const client = new SecretClient(\"https://myvault.vault.azure.net/\", credential);\n}\n```\n\nWhen using this custom credential type, it's the caller's responsibility to ensure the token is valid and contains the correct claims needed to authenticate calls from the particular service client. In the preceding case, the token must have the scope `https://vault.azure.net/.default` to authorize calls to Azure Blob Storage.\n\n### Authenticating with MSAL Directly\n\nSome applications already use the [@azure/msal-node][msal_node_npm] or [@azure/msal-browser][msal_browser_npm] package to authenticate portions of their application. In these cases, the application might want to use the same to authenticate Azure SDK clients, to take advantage of the token caching the MSAL client application is doing, and preventing unnecessary authentication calls.\n\n#### Authenticating with the @azure/msal-node Confidential Client\n\nIn this example, the [ConfidentialClientApplicationCredential](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/master/lib/msal-node/docs/initialize-confidential-client-application.md) is constructed with an instance of `ConfidentialClientApplication` it then implements `getToken()` using the `acquireTokenByClientCredential()` method to acquire a token.\n\n**Prerequisites**\n\nInstall the [@azure/msal-node][msal_node_npm] and [@azure/core-auth][core_auth].\n\n> For more information about MSAL for Node.js, see [the README of the `@azure/msal-node` package][msal_node_readme].\n> For more information about working with the Confidential Client of MSAL, see [Initialization of MSAL (Node.js)](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/master/lib/msal-node/docs/initialize-confidential-client-application.md).\n\n```ts\nimport { TokenCredential, AccessToken } from \"@azure/core-auth\";\nimport * as msalNode from \"@azure/msal-node\";\n\nclass ConfidentialClientCredential implements TokenCredential {\n  constructor(private confidentialApp: msalNode.ConfidentialClientApplication) {}\n  async getToken(scopes: string | string[]): Promise<AccessToken> {\n    const result = await this.confidentialApp.acquireTokenByClientCredential({\n      scopes: Array.isArray(scopes) ? scopes : [scopes]\n    });\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime()\n    };\n  }\n}\n```\n\nUsers could then use the `ConfidentialClientApplicationCredential` to authenticate a `SecretClient` from `@azure/keyvault-secrets` with an MSAL `ConfidentialClientApplication`:\n\n```ts\nimport { SecretClient } from \"@azure/keyvault-secrets\";\nimport * as msalNode from \"@azure/msal-node\";\n\nasync function main() {\n  const confidentialClient = new msalNode.ConfidentialClientApplication({\n    // MSAL Configuration\n  });\n\n  const client = new SecretClient(\n    \"https://myvault.vault.azure.net/\",\n    new ConfidentialClientCredential(confidentialClient)\n  );\n}\n```\n\n#### Authenticating with the @azure/msal-browser Public Client\n\nWhile `@azure/identity` provides some browser support, for users that need the complete feature set offered by `@azure/msal-browser`, it's possible to implement a `TokenCredential` on top of MSAL's public API for the browsers.\n\nFor this example, you'll define a `BrowserCredential` class with the following methods:\n\n- `getToken` &mdash; Will use the Silent Authentication flow, retrieving the account from memory to prevent unnecessary redirections.\n- `prepare` &mdash; Will try either to check if the account has previously authenticated or to parse the redirection URI values if present.\n- `hasAuthenticated` &mdash; Can be used to determine if the authentication has taken place.\n- `loginRedirect` &mdash; If called, this method triggers the authentication via redirection.\n\n**Prerequisites**\n\nInstall the [@azure/msal-browser][msal_browser_npm] and [@azure/core-auth][core_auth] packages.\n\n> For more information about MSAL for browsers, see [the README of the `@azure/msal-browser` package][msal_browser_readme].\n\n```ts\nimport { TokenCredential, AccessToken } from \"@azure/core-auth\";\nimport * as msalBrowser from \"@azure/msal-browser\";\n\nclass BrowserCredential implements TokenCredential {\n  private publicApp: msalBrowser.PublicClientApplication;\n  private hasAuthenticated: boolean = false;\n\n  constructor(clientId, redirectUri) {\n    this.publicApp = new msalBrowser.PublicClientApplication({\n      auth: {\n        clientId,\n        redirectUri\n      }\n    });\n  }\n\n  // Either confirm the account already exists in memory, or tries to parse the redirect URI values.\n  async prepare(): Promise<void> {\n    try {\n      if (await this.publicApp.getActiveAccount()) {\n        this.hasAuthenticated = true;\n        return;\n      }\n      await this.publicApp.handleRedirectPromise();\n      this.hasAuthenticated = true;\n    } catch (e) {\n      console.error(\"BrowserCredential prepare() failed\", e);\n    }\n  }\n\n  // Should be true if prepare() was successful.\n  isAuthenticated(): boolean {\n    return this.hasAuthenticated;\n  }\n\n  // If called, triggers authentication via redirection.\n  async loginRedirect(scopes: string | string[]): Promise<void> {\n    const loginRequest = {\n      scopes: Array.isArray(scopes) ? scopes : [scopes]\n    };\n    await this.app.loginRedirect(loginRequest);\n  }\n\n  // Tries to retrieve the token without triggering a redirection.\n  async getToken(scopes: string | string[]): Promise<AccessToken> {\n    if (!this.hasAuthenticated) {\n      throw new Error(\"Authentication required\");\n    }\n\n    const parameters: msalBrowser.SilentRequest = {\n      account: await this.publicApp.getActiveAccount(),\n      scopes\n    };\n\n    const result = await this.publicApp.acquireTokenSilent(parameters);\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime()\n    };\n  }\n}\n```\n\nThe following example shows how the `BrowserCredential` could be used to authenticate a `ServiceBusClient`. For this example to work, the redirect URI configured in the AAD application should point to the same page that runs this code originally. For example, `http://localhost:80`.\n\n```ts\nimport { ServiceBusClient } from \"@azure/service-bus\";\n\nasync function main() {\n  const browserCredential = new BrowserCredential(clientId, location.origin);\n\n  await browserCredential.prepare();\n\n  if (!browserCredential.isAuthenticated()) {\n    await browserCredential.loginRedirect(\"https://servicebus.azure.net/.default\");\n  }\n\n  const client = new ServiceBusClient(serviceBusEndpoint, browserCredential);\n}\n```\n\n### Authenticating with Key Vault Certificates\n\nAzure Key Vault supports creating secure certificates that can be used to authenticate Azure SDK clients.\n\nThere are different ways to create Key Vault certificates. For example, through the Azure CLI: [Quickstart: Set and retrieve a certificate from Azure Key Vault using Azure CLI](https://docs.microsoft.com/azure/key-vault/certificates/quick-create-cli).\n\nOnce you have a certificate, you may export the certificate with the Azure CLI following the steps at [Export certificates from Azure Key Vault](https://docs.microsoft.com/azure/key-vault/certificates/how-to-export-certificate?tabs=azure-cli).\n\nYou can also export your certificate through the Azure portal. Navigate to your Key Vault resource, go to a specific certificate, then download the certificate in PFX/PEM format.\n\nOnce you have a Key Vault certificate downloaded, go to Azure Active Directory. Find the Enterprise app you want to authenticate with, go to **Certificates & secrets**, and upload the certificate.\n\nAfter that, you can authenticate by pointing the `@azure/identity`'s `ClientCertificateCredential` to the PEM certificate's path, as follows:\n\n```ts\nconst credential = new ClientCertificateCredential(\n  \"<your-tenant-id>\",\n  \"<your-client-id>\",\n  \"<the-path-to-your-certificate-in-PEM-format>\"\n);\n```\n\n### Rolling Certificates\n\nLong-running applications may need to roll certificates during process execution. At the moment, the `ClientCertificateCredential` doesn't support certificate rotation. The credential treats the certificate provided as immutable. Therefore, clients constructed with a `ClientCertificateCredential` using a particular certificate would fail to authenticate requests after that certificate rolls and the original is no longer valid.\n\nHowever, if an application wants to roll this certificate without creating new service clients, it can accomplish this by creating its own `TokenCredential` implementation, which wraps the `ClientCertificateCredential`. Implementing this custom `TokenCredential` would somewhat depend on how the application handles certificate rotation.\n\n#### Explicit rotation\n\nIf the application gets notified of certificate rotations and can directly respond, it might choose to wrap the `ClientCertificateCredential` in a custom credential which provides a means for rotating the certificate.\n\n**Prerequisites**\n\nInstall the [@azure/core-auth][core_auth] package.\n\n```ts\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-auth\";\nimport { ClientCertificateCredential } from \"@azure/identity\";\n\nclass RotatableCertificateCredential implements TokenCredential {\n  private readonly tenantId: string;\n  private readonly clientId: string;\n  private credential: ClientCertificateCredential;\n\n  constructor(tenantId: string, clientId: string, PEMCertificatePath: string) {\n    this.tenantId = tenantId;\n    this.clientId = clientId;\n    this.credential = new ClientCertificateCredential(tenantId, clientId, PEMCertificatePath);\n  }\n\n  async getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken> {\n    return this.credential.getToken(scopes, options);\n  }\n\n  rotateCertificate(PEMCertificatePath: string) {\n    this.credential = new ClientCertificateCredential(\n      this.tenantId,\n      this.clientId,\n      PEMCertificatePath\n    );\n  }\n}\n```\n\nThe preceding example shows a custom credential type `RotatableCertificateCredential`, which provides a `rotateCertificate`. The implementation internally relies on an instance of `ClientCertificateCredential`. `rotateCertificate` replaces this instance with a new one using the new certificate path.\n\n#### Implicit rotation\n\nSome applications might want to respond to certificate rotations that are external to the application. For instance, a separate process rotates the certificate by updating it on disk. Here the application creates a custom credential that checks for certificate updates when tokens are requested.\n\n```ts\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-auth\";\nimport { ClientCertificateCredential } from \"@azure/identity\";\nimport * as fs from \"fs\";\n\nclass RotatingCertificateCredential implements TokenCredential {\n  private readonly tenantId: string;\n  private readonly clientId: string;\n  private readonly certificatePath: string;\n  private promise: Promise<void> | null = null;\n  private credential: ClientCertificateCredential;\n  private lastModified: number = 0;\n\n  constructor(tenantId: string, clientId: string, certificatePath: string) {\n    this.tenantId = tenantId;\n    this.clientId = clientId;\n    this.certificatePath = certificatePath;\n\n    this.refreshCertificate();\n  }\n\n  async getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken> {\n    await this.refreshCertificate();\n\n    return this.credential.getToken(scopes, options);\n  }\n\n  refreshCertificate(): Promise<void> {\n    if (this.promise) {\n      return this.promise;\n    }\n    return new Promise((resolve, reject) => {\n      fs.stat(this.certificatePath, (err, stats) => {\n        if (err) {\n          reject(err);\n        } else {\n          if (this.lastModified < stats.mtime.getTime()) {\n            this.lastModified = stats.mtime.getTime();\n            this.credential = new ClientCertificateCredential(\n              this.tenantId,\n              this.clientId,\n              this.certificatePath\n            );\n            this.promise = null;\n          }\n          resolve();\n        }\n      });\n    });\n  }\n}\n```\n\nIn this example, the custom credential type `RotatingCertificateCredential` again uses a `ClientCertificateCredential` instance to retrieve tokens. However, in this case, it will attempt to refresh the certificate before obtaining the token. The method `RefreshCertificate` will query to see if the certificate has changed. If so, it will replace `this.credential` with a new instance of the certificate credential using the same certificate path.\n\n### Authenticate on behalf of\n\nMany multi-user apps use the [On-Behalf-Of (OBO) flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow) to make authenticated requests between two services that would otherwise be unreachable. The Identity SDK provides an `OnBehalfOfCredential` that supports this form of authentication.\n\nTwo accounts participate in the OBO flow:\n\n- A user, which aims to obtain a special access level. Typically, the `AuthorizationCodeCredential` would be used. We'll call this identity the **User Account**.\n- An app registration, which will act as the provider of the special access level. We'll call this identity the **Target App Registration**.\n\nBoth accounts must belong to the same Azure AD tenant.\n\nWhile other credentials authenticate requesting access to a set of resources, the OBO flow requires the user token to have access specifically to the scope of the Azure AD app that will delegate its access to the users. For this authentication flow to work, the **Target App Registration** must be configured with a custom scope. To create a scope through the Azure portal:\n\n1. Select **Active Directory** > **App registrations**.\n2. Go to the app you want to authenticate against.\n3. On the left menu, select **Expose an API** > **Add a scope**.\n\nThe **Target App Registration** must also have admin consent, which can be granted as follows:\n\n1. Select **Active Directory** > **App registrations**.\n2. Go to the app you want to authenticate against.\n3. On the left menu, select **API permissions** > **Grant admin consent**.\n\nOnce the **Target App Registration** is fully configured, no further configurations are needed on the **User Account** side for the credentials that allow skipping the client ID. In case a specific client ID wants to be specified for the **User Account**, like in the case of the `AuthorizationCodeCredential`, the App Registration used to authenticate in that step must be allowed to authenticate using the scope of the **Target App Registration**. This permission is granted as follows:\n\n1. Select **Active Directory** > **App registrations**.\n2. Go to the app you want to authenticate against.\n3. On the left menu, select **API permissions** > **Add a permission** > **My APIs**.\n4. Select the permission related to the scope that we created for our **Target App Registration**.\n5. Select the **user_impersonation** permission checkbox. Then select **Add permissions**.\n\nAfter everything is set, the code below will work. It will:\n\n1. Authenticate a **User Account** with a credential (in this case, the `InteractiveBrowserCredential`), using the **Target App Registration**'s scope (in this example, `api://AAD_APP_CLIENT_ID/Read`).\n  - If a specific app registration is the desired approach, make sure to use the **User Account** app registration that we mentioned above.\n2. Once the token is retrieved, pass it in the `userAssertionToken` property of the `OnBehalfOfCredentialOptions`, along with `tenantId`, `clientId`, and `clientSecret` of the **Target App Registration**.\n3. Once initialized, this credential will have granted the **User Account** access to the resources available to the **Target App Registration**.\n\n```ts\nimport { InteractiveBrowserCredential, OnBehalfOfCredential } from \"@azure/identity\";\n\nasync function main(): Promise<void> {\n  // Most On-Behalf-Of scenarios would likely use the AuthorizationCodeCredential.\n  const credential = new InteractiveBrowserCredential();\n\n  const token = await credential.getToken(\"api://AAD_APP_CLIENT_ID/Read\");\n\n  const oboCred = new OnBehalfOfCredential({\n    tenantId: \"TENANT\",\n    clientId: \"AAD_APP_CLIENT_ID\",\n    clientSecret: \"AAD_APP_CLIENT_SECRET\",\n    userAssertionToken: token.token\n  });\n\n  // Now, the originally authenticated user will be granted access by the app registration\n  // to previously inaccessible resources.\n  const token2 = await oboCred.getToken(\"https://storage.azure.com/.default\");\n  console.log({ token, token2 });\n}\n\nmain().catch((err) => {\n  console.log(\"error code: \", err.code);\n  console.log(\"error message: \", err.message);\n  console.log(\"error stack: \", err.stack);\n  process.exit(1);\n});\n```\n\n### Control user interaction\n\nIn many cases, applications require tight control over user interaction. In these applications, automatically blocking on required user interaction is often undesired or impractical. For this reason, credentials in the `@azure/identity` library that interact with the user offer mechanisms to fully control user interaction. These settings are available under `InteractiveCredentialOptions` in both Node.js and the browser.\n\n```ts\nconst credential = new InteractiveBrowserCredential({\n  disableAutomaticAuthentication: true\n});\nawait credential.authenticate(\"https://vault.azure.net/.default\");\nconst client = new SecretClient(\"https://key-vault-name.vault.azure.net\", credential);\n```\n\nIn the preceding sample, the application is again using the `InteractiveBrowserCredential` to authenticate a `SecretClient`. There are two major differences from our first example. In this example:\n\n- The application is explicitly forcing any user interaction to happen before the credential is given to the client by calling the `authenticate` method.\n- The application is preventing the credential from automatically initiating user interaction. Even though the application authenticates the user before the credential is used, further interaction might still be needed. For instance, in the case that the user's refresh token expires or that a specific method requires additional consent or authentication.\n\nIf `disableAutomaticAuthentication` is `false`, the user doesn't use `authenticate()`, and the user has never authenticated before, `getToken` will prompt the user to authenticate.\n\nBy setting the option `disableAutomaticAuthentication` to `true`, the credential will fail to automatically authenticate calls in which user interaction is necessary. Instead, the credential will throw an `AuthenticationRequiredError`. If `disableAutomaticAuthentication` is set to `true`, the user doesn't use `authenticate()`, and the user has never authenticated before, `getToken` should fail hard.\nThe following example demonstrates an application handling such an exception to prompt the user to authenticate only after some application logic has completed.\n\n```ts\ntry {\n  await client.getSecret(\"secret-name\");\n} catch (e) {\n  if (e.name === \"AuthenticationRequiredError\") {\n    await credential.authenticate(e.scopes);\n    console.log(\"Secret\", await client.getSecret(\"secret-name\"));\n  } else {\n    throw e;\n  }\n}\n```\n\n### Persist user authentication data\n\nQuite often, applications desire the ability to be run multiple times without re-authenticating the user on each execution. This requires that data from credentials be persisted outside of the application memory to authenticate silently on subsequent executions. Applications can persist this data using `tokenCachePersistenceOptions` when constructing the credential and persisting the `authenticationRecord` returned from `authenticate`.\n\nMany credential implementations in the `@azure/identity` library have an underlying token cache that persists sensitive authentication data such as account information, access tokens, and refresh tokens. By default, this data exists in an in-memory cache, which is specific to the credential instance. However, there are scenarios in which an application needs to persist it across executions to share the token cache across credentials. To accomplish this, the `@azure/identity` library provides the `tokenCachePersistenceOptions`.\n\n> IMPORTANT! The token cache contains sensitive data and MUST be protected to prevent compromising accounts. All application decisions regarding the persistence of the token cache must consider that a breach of its content will fully compromise all the accounts it contains.\n\nStarting in version 2 of `@azure/identity`, the `@azure/identity-cache-persistence` package can be used. This package provides a plugin to the `@azure/identity` package to enable persistent token caching. The package `@azure/identity-cache-persistence` exports a plugin object that you must pass as an argument to the top-level `useIdentityPlugin` function from the `@azure/identity` package.\n\n```\nnpm install --save @azure/identity-cache-persistence\n```\n\nEnable token cache persistence in your application as follows:\n\n```ts\nimport { useIdentityPlugin } from \"@azure/identity\";\nimport { cachePersistencePlugin } from \"@azure/identity-cache-persistence\";\n\nuseIdentityPlugin(cachePersistencePlugin);\n```\n\nAfter calling `useIdentityPlugin`, the persistent token cache plugin is registered to the `@azure/identity` package and will be available on all credentials that support persistent token caching (those that have `tokenCachePersistenceOptions` in their constructor options).\n\n#### Persist the token cache\n\nThe credential handles persisting all the data needed to silently authenticate one or many accounts. It manages sensitive data, such as refresh tokens and access tokens, which must be protected to prevent compromising the accounts related to them. The `@azure/identity` library will protect and cache sensitive token data, using available platform data protection, if `@azure/identity-cache-persistence` is configured. Otherwise, it will use only in-memory caching.\n\nTo configure a credential, such as the `InteractiveBrowserCredential`, to persist token data, set the `tokenCachePersistenceOptions` option. The simplest way to persist the token data for a credential is to use the default `tokenCachePersistenceOptions`. This will persist and read token data from a shared persisted token cache protected to the current account.\n\n```ts\nimport { useIdentityPlugin, InteractiveBrowserCredential } from \"@azure/identity\";\nimport { cachePersistencePlugin } from \"@azure/identity-cache-persistence\";\n\nuseIdentityPlugin(cachePersistencePlugin);\n\nconst credential = new InteractiveBrowserCredential({\n  tokenCachePersistenceOptions: {\n    enabled: true\n  }\n});\n```\n\n#### Use a named token cache\n\nSome applications may prefer to isolate the token cache they use and provide a unique identifier, instead of using the default. To accomplish this, specify the `tokenCachePersistenceOptions` when creating the credential and provide a `name` for the persisted cache instance.\n\n```ts\nconst credential = new InteractiveBrowserCredential({\n  tokenCachePersistenceOptions: {\n    enabled: true,\n    name: \"my_application_name\"\n  }\n});\n```\n\n#### Persist the authentication record\n\nThe `AuthenticationRecord` which is returned from the `authenticate`, contains data identifying an authenticated account. It's needed to identify the appropriate entry in the persisted token cache to silently authenticate on subsequent executions. There's no sensitive data in the `AuthenticationRecord`, so it can be persisted in a non-protected state. Ensure that you pass the appropriate scopes for your service to the `authenticate` method.\n\nThe following example stores the `AuthenticationRecord` to the local file system after authenticating the user:\n\n```ts\nimport {\n  useIdentityPlugin,\n  InteractiveBrowserCredential,\n  AuthenticationRecord,\n  serializeAuthenticationRecord\n} from \"@azure/identity\";\nimport { cachePersistencePlugin } from \"@azure/identity-cache-persistence\";\nimport { writeFileSync } from \"fs\";\nimport path from \"path\";\n\nuseIdentityPlugin(cachePersistencePlugin);\n\nexport async function main(): Promise<void> {\n  const AUTH_RECORD_PATH = \"./tokencache.bin\";\n  const credential = new InteractiveBrowserCredential({\n    tokenCachePersistenceOptions: {\n      enabled: true\n    }\n  });\n  const authRecord: AuthenticationRecord = await credential.authenticate(\n    \"https://service/.default\"\n  );\n  const content = serializeAuthenticationRecord(authRecord);\n  writeFileSsync(path.join(process.cwd(), AUTH_RECORD_PATH), content);\n}\n\nmain().catch((err) => {\n  console.log(\"error code: \", err.code);\n  console.log(\"error message: \", err.message);\n  console.log(\"error stack: \", err.stack);\n  process.exit(1);\n});\n```\n\n#### Silent authentication with authentication record and token cache persistence options\n\nOnce an application has configured a credential to persist token data and an `AuthenticationRecord`, it's possible to silently authenticate. The following example demonstrates setting the `tokenCachePersistenceOptions` and retrieving an `AuthenticationRecord` from the local file system to create an `InteractiveBrowserCredential` capable of silent authentication.\n\n```ts\nimport {\n  useIdentityPlugin,\n  InteractiveBrowserCredential,\n  AuthenticationRecord,\n  deserializeAuthenticationRecord\n} from \"@azure/identity\";\nimport { cachePersistencePlugin } from \"@azure/identity-cache-persistence\";\nimport { readFileSync } from \"fs\";\nimport path from \"path\";\n\nuseIdentityPlugin(cachePersistencePlugin);\n\nexport async function main(): Promise<void> {\n  const AUTH_RECORD_PATH = \"./tokencache.bin\";\n  const fileContent = readFileSync(path.join(process.cwd(), AUTH_RECORD_PATH), {\n    encoding: \"utf-8\"\n  });\n  const authRecord: AuthenticationRecord = deserializeAuthenticationRecord(fileContent);\n\n  const credential = new InteractiveBrowserCredential({\n    tokenCachePersistenceOptions: {\n      enabled: true\n    },\n    authenticationRecord: authRecord\n  });\n}\n\nmain().catch((err) => {\n  console.log(\"error code: \", err.code);\n  console.log(\"error message: \", err.message);\n  console.log(\"error stack: \", err.stack);\n  process.exit(1);\n});\n```\n\nThe credential created in the preceding example will silently authenticate, given that a valid token corresponding to the `AuthenticationRecord` still exists in the persisted token data. There are some cases where interaction will still be required, such as on token expiry or when additional authentication is required for a particular resource.\n\n#### Allow unencrypted storage\n\nBy default, the token cache will protect any data that is persisted using the user data protection APIs available on the current platform. However, there are cases where no data protection is available, and applications may choose to still persist the token cache in an unencrypted state. This is accomplished with the `unsafeAllowUnencryptedStorage` option.\n\n```ts\nimport { useIdentityPlugin, InteractiveBrowserCredential } from \"@azure/identity\";\nimport { cachePersistencePlugin } from \"@azure/identity-cache-persistence\";\n\nuseIdentityPlugin(cachePersistencePlugin);\n\nconst credential = new InteractiveBrowserCredential({\n  tokenCachePersistenceOptions: {\n    enabled: true,\n    unsafeAllowUnencryptedStorage: true\n  }\n});\n```\n\nBy setting `unsafeAllowUnencryptedStorage` to `true`, the credential will encrypt the contents of the token cache before persisting it, if data protection is available on the current platform. If platform data protection is unavailable, it will write and read the persisted token data to an unencrypted local file with access permissions restricted to the current user. If `unsafeAllowUnencryptedStorage` is `false` (the default), a `CredentialUnavailableError` will be thrown in the case that no data protection is available.\n\n### Authenticate national clouds\n\nNational clouds are physically isolated instances of Azure. These regions of Azure are designed to make sure that data residency, sovereignty, and compliance requirements are honored within geographical boundaries. Including the global cloud, Azure Active\u202fDirectory\u202f(Azure AD) is deployed in the following national clouds:\n\n- Azure Government\n- Azure Germany\n- Azure China 21Vianet\n\nAll credentials have `authorityHost` as a setting in the constructor at some level. To authenticate for various national cloud or a private cloud, we can send the most appropriate `authorityHost`. We provide a set of common values through the `AzureAuthorityHosts` interface. So, for the US Government cloud, you could instantiate a credential this way:\n\n```ts\nimport { AzureAuthorityHosts, ClientSecretCredential } from \"@azure/identity\";\nconst credential = new ClientSecretCredential(\n  \"<YOUR_TENANT_ID>\",\n  \"<YOUR_CLIENT_ID>\",\n  \"<YOUR_CLIENT_SECRET>\",\n  {\n    authorityHost: AzureAuthorityHosts.AzureGovernment\n  }\n);\n```\n\nThe following table shows common values provided through the `AzureAuthorityHosts`.\n\n| National Cloud                      | Azure AD authentication endpoint  | AzureAuthorityHost                     |\n| ----------------------------------- | --------------------------------- | -------------------------------------- |\n| Azure AD for US Government          | https://login.microsoftonline.us  | `AzureAuthorityHosts.AzureGovernment`  |\n| Azure AD Germany                    | https://login.microsoftonline.de  | `AzureAuthorityHosts.AzureGermany`     |\n| Azure AD China operated by 21Vianet | https://login.chinacloudapi.cn    | `AzureAuthorityHosts.AzureChina`       |\n| Azure AD (global service)           | https://login.microsoftonline.com | `AzureAuthorityHosts.AzurePublicCloud` |\n\nTo learn more about Azure Authentication for National Clouds, see [National clouds](https://docs.microsoft.com/azure/active-directory/develop/authentication-national-cloud).\n\n<!-- LINKS -->\n\n[azure_cli]: https://docs.microsoft.com/cli/azure\n[secrets_client_library]: https://www.npmjs.com/package/@azure/keyvault-secrets\n[service_bus_client_library]: https://www.npmjs.com/package/@azure/service-bus\n[azure_managed_identities]: https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview\n[service_principal_azure_cli]: https://docs.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli\n[device_code_flow]: https://github.com/Azure/azure-sdk-for-java/wiki/Set-up-Your-Environment-for-Authentication#enable-applications-for-device-code-flow\n[quickstart-register-app]: https://docs.microsoft.com/azure/active-directory/develop/quickstart-register-app\n[app-register-service-principal]: https://docs.microsoft.com/azure/active-directory/develop/app-objects-and-service-principals\n[service_principal_azure_powershell]: https://docs.microsoft.com/powershell/azure/create-azure-service-principal-azureps\n[msal_node_readme]: https://github.com/sadasant/microsoft-authentication-library-for-js/tree/master/lib/msal-node\n[msal_node_npm]: https://www.npmjs.com/package/@azure/msal-node\n[msal_browser_readme]: https://github.com/sadasant/microsoft-authentication-library-for-js/tree/master/lib/msal-browser\n[msal_browser_npm]: https://www.npmjs.com/package/@azure/msal-browser\n[core_auth]: https://www.npmjs.com/package/@azure/core-auth\n[register_certificate_app_registration]: https://docs.microsoft.com/azure/active-directory/develop/active-directory-certificate-credentials#register-your-certificate-with-microsoft-identity-platform\n[client_assertion_jwt]: https://docs.microsoft.com/azure/active-directory/develop/active-directory-certificate-credentials\n", "repo_name": "identity/identity/samples/AzureIdentityExamples.md", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/identity/identity/samples/AzureIdentityExamples.md", "language": ["JavaScript"]}, {"README_text": "", "repo_name": "tables/data-tables/samples/.gitkeep", "link_to_repo": "https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/tables/data-tables/samples/.gitkeep", "language": ["JavaScript"]}]